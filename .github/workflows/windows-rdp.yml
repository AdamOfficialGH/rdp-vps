name: Windows RDP

on:
  workflow_dispatch:
    inputs:
      duration:
        description: 'Duration in hours (max 6)'
        required: false
        default: '6'
        type: string
      password:
        description: 'Custom RDP password (optional)'
        required: false
        type: string

jobs:
  build:
    runs-on: windows-latest
    timeout-minutes: 360  # 6 hours max

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Enable RDP
      run: |
        # Enable RDP
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -name "fDenyTSConnections" -value 0
        Enable-NetFirewallRule -DisplayGroup "Remote Desktop"
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -name "UserAuthentication" -value 1
        
        # Set password for runneradmin user
        $password = "${{ github.event.inputs.password }}"
        if ([string]::IsNullOrEmpty($password)) {
          $password = "${{ secrets.RDP_PASSWORD }}"
        }
        if ([string]::IsNullOrEmpty($password)) {
          $password = "P@ssw0rd123!"
        }
        
        net user runneradmin $password
        net localgroup "Remote Desktop Users" runneradmin /add
        
        Write-Host "RDP enabled successfully!"
        Write-Host "Username: runneradmin"
        Write-Host "Password: $password"

    - name: Install Chocolatey
      run: |
        Set-ExecutionPolicy Bypass -Scope Process -Force
        [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
        iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))

    - name: Install Essential Software
      run: |
        choco install -y googlechrome
        choco install -y firefox
        choco install -y 7zip
        choco install -y notepadplusplus
        choco install -y git
        choco install -y nodejs
        choco install -y python
        choco install -y vscode
        choco install -y putty
        choco install -y winscp

    - name: Download and setup ngrok
      run: |
        # Download ngrok
        Write-Host "üì• Downloading ngrok..."
        Invoke-WebRequest -Uri "https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-windows-amd64.zip" -OutFile "ngrok.zip"

        # Extract to current directory instead of C:\ngrok
        Write-Host "üì¶ Extracting ngrok..."
        Expand-Archive -Path "ngrok.zip" -DestinationPath "." -Force

        # Verify ngrok exists
        if (Test-Path ".\ngrok.exe") {
          Write-Host "‚úÖ Ngrok extracted successfully"
          .\ngrok.exe version
        } else {
          Write-Host "‚ùå Ngrok extraction failed"
          exit 1
        }

    - name: Setup ngrok tunnel
      run: |
        # Configure ngrok with auth token
        Write-Host "üîê Configuring ngrok auth token..."
        .\ngrok.exe config add-authtoken ${{ secrets.NGROK_AUTH_TOKEN }}

        # Kill any existing ngrok processes
        Write-Host "üßπ Cleaning up existing ngrok processes..."
        Get-Process -Name "ngrok" -ErrorAction SilentlyContinue | Stop-Process -Force
        Start-Sleep -Seconds 3

        # Start ngrok tunnel in background with proper logging
        Write-Host "üöÄ Starting ngrok tunnel for RDP (port 3389)..."

        # Use cmd to start ngrok in background
        $ngrokCmd = ".\ngrok.exe tcp 3389 --log=stdout"
        Start-Process -FilePath "cmd.exe" -ArgumentList "/c", $ngrokCmd -WindowStyle Hidden -RedirectStandardOutput "ngrok.log" -RedirectStandardError "ngrok_error.log"

        # Wait for ngrok to start
        Write-Host "‚è≥ Waiting for ngrok to initialize..."
        Start-Sleep -Seconds 20

        # Check if ngrok process is running
        $ngrokProcess = Get-Process -Name "ngrok" -ErrorAction SilentlyContinue
        if ($ngrokProcess) {
          Write-Host "‚úÖ Ngrok process started successfully (PID: $($ngrokProcess.Id))"
        } else {
          Write-Host "‚ùå Ngrok process failed to start"
          Write-Host "üìã Checking error logs..."
          if (Test-Path "ngrok_error.log") {
            Get-Content "ngrok_error.log"
          }
        }

    - name: Get ngrok tunnel info
      run: |
        # Wait for ngrok API to be ready
        $maxAttempts = 20
        $attempt = 1
        $tunnelFound = $false

        Write-Host "üîç Waiting for ngrok tunnel to be ready..."

        while ($attempt -le $maxAttempts -and -not $tunnelFound) {
          try {
            Write-Host "Attempt $attempt/$maxAttempts - Checking ngrok API..."

            # Check if ngrok process is still running
            $ngrokProcess = Get-Process -Name "ngrok" -ErrorAction SilentlyContinue
            if (-not $ngrokProcess) {
              Write-Host "‚ö†Ô∏è Ngrok process not found, restarting..."
              $ngrokCmd = ".\ngrok.exe tcp 3389 --log=stdout"
              Start-Process -FilePath "cmd.exe" -ArgumentList "/c", $ngrokCmd -WindowStyle Hidden -RedirectStandardOutput "ngrok.log" -RedirectStandardError "ngrok_error.log"
              Start-Sleep -Seconds 15
            }

            $response = Invoke-RestMethod -Uri "http://localhost:4040/api/tunnels" -Method Get -TimeoutSec 10
            $tunnel = $response.tunnels | Where-Object { $_.proto -eq "tcp" }

            if ($tunnel) {
              $address = $tunnel.public_url -replace "tcp://", ""
              Write-Host "=================================="
              Write-Host "üéâ RDP IS READY!"
              Write-Host "=================================="
              Write-Host "RDP Address: $address"
              Write-Host "Username: runneradmin"
              Write-Host "Password: $(if ('${{ github.event.inputs.password }}') { '${{ github.event.inputs.password }}' } elseif ('${{ secrets.RDP_PASSWORD }}') { '${{ secrets.RDP_PASSWORD }}' } else { 'P@ssw0rd123!' })"
              Write-Host "=================================="
              Write-Host ""
              Write-Host "üìã Instructions:"
              Write-Host "1. Open Remote Desktop Connection"
              Write-Host "2. Enter the address above"
              Write-Host "3. Use the username and password"
              Write-Host "4. Click Connect!"
              Write-Host ""
              Write-Host "‚è∞ Session will last for ${{ github.event.inputs.duration || '6' }} hours"
              Write-Host "=================================="
              $tunnelFound = $true
            } else {
              Write-Host "‚è≥ No tunnel found yet, waiting..."
            }
          } catch {
            Write-Host "‚è≥ Ngrok API not ready yet: $($_.Exception.Message)"
          }

          if (-not $tunnelFound) {
            Start-Sleep -Seconds 15
            $attempt++
          }
        }

        if (-not $tunnelFound) {
          Write-Host "‚ùå Failed to establish ngrok tunnel after $maxAttempts attempts"
          Write-Host "üîß Troubleshooting tips:"
          Write-Host "1. Check if NGROK_AUTH_TOKEN is correct"
          Write-Host "2. Verify ngrok account is not rate limited"
          Write-Host "3. Try restarting the workflow"
        }

    - name: Keep session alive
      run: |
        $duration = [int]"${{ github.event.inputs.duration || '6' }}"
        $endTime = (Get-Date).AddHours($duration)
        
        Write-Host "üîÑ Keeping session alive until $(Get-Date $endTime -Format 'yyyy-MM-dd HH:mm:ss')"
        
        while ((Get-Date) -lt $endTime) {
          Write-Host "‚è∞ Session active - $(Get-Date -Format 'HH:mm:ss') - Remaining: $([math]::Round(($endTime - (Get-Date)).TotalMinutes, 1)) minutes"
          
          # Check if ngrok is still running
          $ngrokProcess = Get-Process -Name "ngrok" -ErrorAction SilentlyContinue
          if (-not $ngrokProcess) {
            Write-Host "‚ö†Ô∏è Ngrok process died, restarting..."
            $ngrokCmd = ".\ngrok.exe tcp 3389 --log=stdout"
            Start-Process -FilePath "cmd.exe" -ArgumentList "/c", $ngrokCmd -WindowStyle Hidden -RedirectStandardOutput "ngrok.log" -RedirectStandardError "ngrok_error.log"
            Start-Sleep -Seconds 20

            # Try to get tunnel info again after restart
            try {
              Start-Sleep -Seconds 5
              $response = Invoke-RestMethod -Uri "http://localhost:4040/api/tunnels" -Method Get -TimeoutSec 10
              $tunnel = $response.tunnels | Where-Object { $_.proto -eq "tcp" }
              if ($tunnel) {
                $address = $tunnel.public_url -replace "tcp://", ""
                Write-Host "üîÑ Tunnel restored: $address"
              }
            } catch {
              Write-Host "‚ö†Ô∏è Could not restore tunnel info"
            }
          }
          
          # Keep system active
          Add-Type -AssemblyName System.Windows.Forms
          [System.Windows.Forms.SendKeys]::SendWait("{SCROLLLOCK}")
          
          Start-Sleep -Seconds 300  # Wait 5 minutes
        }
        
        Write-Host "‚è∞ Session time expired. Shutting down..."

    - name: Cleanup
      if: always()
      run: |
        Write-Host "üßπ Cleaning up..."
        Stop-Process -Name "ngrok" -Force -ErrorAction SilentlyContinue
        Write-Host "‚úÖ Cleanup completed"
